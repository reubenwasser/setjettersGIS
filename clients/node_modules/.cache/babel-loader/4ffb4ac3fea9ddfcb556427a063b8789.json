{"ast":null,"code":"var wgs84 = require('wgs84');\n\nmodule.exports.geometry = geometry;\nmodule.exports.ring = ringArea;\n\nfunction geometry(_) {\n  if (_.type === 'Polygon') return polygonArea(_.coordinates);else if (_.type === 'MultiPolygon') {\n    var area = 0;\n\n    for (var i = 0; i < _.coordinates.length; i++) {\n      area += polygonArea(_.coordinates[i]);\n    }\n\n    return area;\n  } else {\n    return null;\n  }\n}\n\nfunction polygonArea(coords) {\n  var area = 0;\n\n  if (coords && coords.length > 0) {\n    area += Math.abs(ringArea(coords[0]));\n\n    for (var i = 1; i < coords.length; i++) {\n      area -= Math.abs(ringArea(coords[i]));\n    }\n  }\n\n  return area;\n}\n/**\n * Calculate the approximate area of the polygon were it projected onto\n *     the earth.  Note that this area will be positive if ring is oriented\n *     clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n *     Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * Returns:\n * {float} The approximate signed geodesic area of the polygon in square\n *     meters.\n */\n\n\nfunction ringArea(coords) {\n  var area = 0;\n\n  if (coords.length > 2) {\n    var p1, p2;\n\n    for (var i = 0; i < coords.length - 1; i++) {\n      p1 = coords[i];\n      p2 = coords[i + 1];\n      area += rad(p2[0] - p1[0]) * (2 + Math.sin(rad(p1[1])) + Math.sin(rad(p2[1])));\n    }\n\n    area = area * wgs84.RADIUS * wgs84.RADIUS / 2;\n  }\n\n  return area;\n}\n\nfunction rad(_) {\n  return _ * Math.PI / 180;\n}","map":{"version":3,"sources":["/home/rwasser/setjetters/setjettersGIS/clients/node_modules/geojson-area/index.js"],"names":["wgs84","require","module","exports","geometry","ring","ringArea","_","type","polygonArea","coordinates","area","i","length","coords","Math","abs","p1","p2","rad","sin","RADIUS","PI"],"mappings":"AAAA,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAnB;;AAEAC,MAAM,CAACC,OAAP,CAAeC,QAAf,GAA0BA,QAA1B;AACAF,MAAM,CAACC,OAAP,CAAeE,IAAf,GAAsBC,QAAtB;;AAEA,SAASF,QAAT,CAAkBG,CAAlB,EAAqB;AACjB,MAAIA,CAAC,CAACC,IAAF,KAAW,SAAf,EAA0B,OAAOC,WAAW,CAACF,CAAC,CAACG,WAAH,CAAlB,CAA1B,KACK,IAAIH,CAAC,CAACC,IAAF,KAAW,cAAf,EAA+B;AAChC,QAAIG,IAAI,GAAG,CAAX;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,CAAC,CAACG,WAAF,CAAcG,MAAlC,EAA0CD,CAAC,EAA3C,EAA+C;AAC3CD,MAAAA,IAAI,IAAIF,WAAW,CAACF,CAAC,CAACG,WAAF,CAAcE,CAAd,CAAD,CAAnB;AACH;;AACD,WAAOD,IAAP;AACH,GANI,MAME;AACH,WAAO,IAAP;AACH;AACJ;;AAED,SAASF,WAAT,CAAqBK,MAArB,EAA6B;AACzB,MAAIH,IAAI,GAAG,CAAX;;AACA,MAAIG,MAAM,IAAIA,MAAM,CAACD,MAAP,GAAgB,CAA9B,EAAiC;AAC7BF,IAAAA,IAAI,IAAII,IAAI,CAACC,GAAL,CAASV,QAAQ,CAACQ,MAAM,CAAC,CAAD,CAAP,CAAjB,CAAR;;AACA,SAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGE,MAAM,CAACD,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACpCD,MAAAA,IAAI,IAAII,IAAI,CAACC,GAAL,CAASV,QAAQ,CAACQ,MAAM,CAACF,CAAD,CAAP,CAAjB,CAAR;AACH;AACJ;;AACD,SAAOD,IAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASL,QAAT,CAAkBQ,MAAlB,EAA0B;AACtB,MAAIH,IAAI,GAAG,CAAX;;AAEA,MAAIG,MAAM,CAACD,MAAP,GAAgB,CAApB,EAAuB;AACnB,QAAII,EAAJ,EAAQC,EAAR;;AACA,SAAK,IAAIN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGE,MAAM,CAACD,MAAP,GAAgB,CAApC,EAAuCD,CAAC,EAAxC,EAA4C;AACxCK,MAAAA,EAAE,GAAGH,MAAM,CAACF,CAAD,CAAX;AACAM,MAAAA,EAAE,GAAGJ,MAAM,CAACF,CAAC,GAAG,CAAL,CAAX;AACAD,MAAAA,IAAI,IAAIQ,GAAG,CAACD,EAAE,CAAC,CAAD,CAAF,GAAQD,EAAE,CAAC,CAAD,CAAX,CAAH,IAAsB,IAAIF,IAAI,CAACK,GAAL,CAASD,GAAG,CAACF,EAAE,CAAC,CAAD,CAAH,CAAZ,CAAJ,GAA2BF,IAAI,CAACK,GAAL,CAASD,GAAG,CAACD,EAAE,CAAC,CAAD,CAAH,CAAZ,CAAjD,CAAR;AACH;;AAEDP,IAAAA,IAAI,GAAGA,IAAI,GAAGX,KAAK,CAACqB,MAAb,GAAsBrB,KAAK,CAACqB,MAA5B,GAAqC,CAA5C;AACH;;AAED,SAAOV,IAAP;AACH;;AAED,SAASQ,GAAT,CAAaZ,CAAb,EAAgB;AACZ,SAAOA,CAAC,GAAGQ,IAAI,CAACO,EAAT,GAAc,GAArB;AACH","sourcesContent":["var wgs84 = require('wgs84');\n\nmodule.exports.geometry = geometry;\nmodule.exports.ring = ringArea;\n\nfunction geometry(_) {\n    if (_.type === 'Polygon') return polygonArea(_.coordinates);\n    else if (_.type === 'MultiPolygon') {\n        var area = 0;\n        for (var i = 0; i < _.coordinates.length; i++) {\n            area += polygonArea(_.coordinates[i]);\n        }\n        return area;\n    } else {\n        return null;\n    }\n}\n\nfunction polygonArea(coords) {\n    var area = 0;\n    if (coords && coords.length > 0) {\n        area += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            area -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return area;\n}\n\n/**\n * Calculate the approximate area of the polygon were it projected onto\n *     the earth.  Note that this area will be positive if ring is oriented\n *     clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n *     Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * Returns:\n * {float} The approximate signed geodesic area of the polygon in square\n *     meters.\n */\n\nfunction ringArea(coords) {\n    var area = 0;\n\n    if (coords.length > 2) {\n        var p1, p2;\n        for (var i = 0; i < coords.length - 1; i++) {\n            p1 = coords[i];\n            p2 = coords[i + 1];\n            area += rad(p2[0] - p1[0]) * (2 + Math.sin(rad(p1[1])) + Math.sin(rad(p2[1])));\n        }\n\n        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;\n    }\n\n    return area;\n}\n\nfunction rad(_) {\n    return _ * Math.PI / 180;\n}\n"]},"metadata":{},"sourceType":"script"}